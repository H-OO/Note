# HTTP协议

简介：HTTP 是基于 TCP/IP协议的应用层协议  
作用：不涉及数据包传输，主要规定了浏览器和服务器之间的通信格式，默认使用80端口  

流程
```
TCP连接建立后
浏览器向服务器发送请求报文
服务器向浏览器发送响应报文
服务器发送完毕后就断开TCP连接
```

历史
* HTTP/0.9 只支持文字，只支持GET命令
* HTTP/1.0 支持文字、图片、视频、二进制文件，支持GET、POST、HEAD命令
* HTTP/1.1 优化
* HTTP/2   安全

## HTTP/1.0

支持格式：文字、图片、音频、视频、二进制文件  
支持命令：GET、POST、HEAD  

每次通信都必须包括头信息（HTTP header），描述浏览器情况

1.0版本 请求命令后面要添加协议版本
```
/**
  * 请求格式
  * 第一行是请求命令+版本号
  * 后面多行也是头信息
  */
GET / HTTP/1.0
Accept: */*
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)
```

响应格式：头信息+空行+数据
```
/**
  * 响应格式
  * 第一行是版本号+状态码+状态描述
  */
HTTP/1.0 200 OK
Content-Type: text/plain
```

**Content-Type**
---
作用：告诉浏览器数据的返回格式  
原因：1.0版本规定头信息必须是ASCII码，后面的数据可以是任意格式  

常见值
* text/[plain|html|css] 字符串，无格式|html文件格式|css文件格式
* image/[jpeg|png|gif|x-icon] 图片，文件后缀为 .jpeg|.png|.gif|.icon
* audio/mp3 音频，音频文件后缀为 .mp3
* video/mp4 视频，视频文件后缀为 .mp4
* application/[javascript|pdf|zip] 二进制文件，文件后缀为 .js|.pdf|.zip

更多可搜索对照表

这些数据类型总称为 MIME type

MIME type 通过在尾部使用分号，可以添加参数
```
Content-Type: text/html; charset=utf-8 // 返回html格式，编码是utf-8
```

**Accept**
---
作用：浏览器告诉服务器可以处理哪些数据格式
```
Accept: */* // 可处理任何格式的数据
```

**Content-Encoding**
---
作用：告诉浏览器数据的压缩方式

Content-Encoding: [gzip|compress|deflate]

**Accept-Encoding**
---
作用：告诉服务器可处理的压缩方式

Accept-Encoding: gzip, deflate

**HTTP/1.0缺点**
---
问题：  
每个TCP连接只能发生一个请求，数据发送完毕就会断开连接  
如果还要请求其他资源，就必须再新建一个连接  
TCP连接的新建成本很高，需要浏览器与服务器三次握手，而且开始时发送速率较慢

解决：（非标准）
添加非标准的Connection字段，这个字段要求服务器不要关闭TCP连接，以便其他请求复用  
```
Connection: keep-alive
```
浏览器添加该字段，服务器同样回应该字段  
一个可复用的TCP连接就建立了，直到浏览器或服务器主动关闭连接

## HTTP/1.1

持久连接：可以被多个请求复用，不用声明 Content: keep-alive

断开连接的规范做法：浏览器在最后一个请求时，发送 Connection: close，明确要求服务器关闭TCP连接

管道机制：浏览器允许同时发送多个请求(优化)，服务器依旧按照顺序逐个回应

**Content-Length**
---
作用：声明本次回应的数据长度，区分数据包属于哪一个回应
```
Content-Length: 1234 // 告诉浏览器本次响应的长度是1234个字节，之后的字节属于下一个响应的数据包
```

**分块传输**
---
作用：不需要回应数据的总长度，在产生一块数据时就发送一块，简称流模式。
优点：边读取边发送，比读取完再发送效率更高
```
Content-Length: 1234 // 缓存模式
Transfer-Encoding: chunked // 流模式(推荐，效率高)
```
```
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
squence

0
```
在数据块之前有一个16进制的数值，用来表示这个快的长度  
最后是一个大小为0的块，用来表示本次响应的数据发送完了

**新增**
---
命令
* PUT
* PATCH
* HEAD
* OPTIONS
* DELETE

**Host**
---
作用：浏览器请求的头信息字段，用于指定服务器的域名

**HTTP/1.1缺点**
---
问题：队头堵塞

原因：  
同一个TCP连接里面，所有的数据通信是按次序进行的；  
也就是服务器只有处理完一个回应后，才会进行下一个回应；  
而且前面的回应特别慢，后面就会有许多请求排队等着，这种情况称为队头堵塞。

解决：  
1.减少HTTP请求数（前端优化）  
2.同时多开持久连接

## HTTP/2

* 二进制协议
* 多工
* 数据流

**二进制协议**
---
作用：方便解析数据

HTTP/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧（头信息帧和数据帧）

二进制协议的好处是可以定义额外的帧。HTTP/2定义了近十种帧为高级应用打好了基础。

**多工**
---
作用：避免队头堵塞

HTTP/2复用TCP连接，在一个连接里，浏览器可以同时发送多个请求，服务器可同时回应多个，不用按照顺序一一对应。

例如：服务器同时收到了A请求和B请求的处理过程
```
先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分
↓
接着回应B请求
↓
完成后，再发送A请求剩下的部分
```
多工就是双向的、实时的通信

**数据流**
---
指每个请求或回应的所有数据包，称为一个数据流

每个数据流都有一个唯一的编号，用于区分它属于哪一个回应

数据包发送时必须标记数据流ID，用于区分它属于哪个数据流

规定：浏览器发出的数据流，ID一律为奇数；服务器发出的数据流，ID一律为偶数

数据流发送到一半的时候，浏览器和服务器都可以发送信号（RST_STREAM帧），取消这个数据流

HTTP/1.1取消数据流的唯一方法就是关闭TCP连接  
HTTP/2可以取消某一个请求，同时保证TCP连接还打开着

浏览器可以指定数据流的优先级。优先级越高，服务器就会越早回应

**头信息压缩**
---
HTTP/[0.9|1.0|1.1]协议不带有状态，每次请求都必须附上所有信息。  
由于很多字段都是重复的，例如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，浪费带宽也影响速度。  

HTTP/2对这一点做了优化，引入了头信息压缩机制。  
一方面，头信息使用 gzip 和 compress 压缩后再发生；  
另一方面，浏览器和服务器同时维护一张头信息表，  
所有字段都会存入这个表，生成一个索引号，  
以后就不发送同样字段，只发索引号，这样就提升速度了。

**服务器推送**
---
HTTP/2允许服务器未经请求，主动向客户端发送资源。

常见场景：客户端请求一个网页，网页里面包含很多静态资源。  
正常情况下，浏览器必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。

HTTP/2优化后，服务器可以预料到浏览器获取页面后，会再次请求静态资源，所以主动把这些静态资源随着网页一起发给了浏览器。

## HTTPS

HTTP/2协议只有在HTTPS环境才会生效

**证书**
---
证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，要从经销商购买

认证级别
* 域名认证 最低级别认证，可以确认申请人拥有这个域名（浏览器地址栏会显示一把锁）
* 公司认证 确认域名所有人是哪一家公司，证书里面包含公司信息
* 扩展认证 最高级别认证（浏览器地址栏会显示公司名）

覆盖范围
* 单域名证书 只能用于单个域名，test.com 的证书不能用于 www.test.com
* 通配符证书 可用于某个域名及其所有一级子域名，比如 *.test.com 的证书可以用于 test.com 和 www.test.com
* 多域名证书 可用于多个域名，比如 test1.com 和 test2.com

**安装证书**
---
证书可以放在 `/etc/ssl` 目录（Linux系统）

* 证书配置文件生成器
* 配置文件模板

**安全措施**
---
措施1：强制浏览器只能发出HTTPS请求，并阻止用户接受不安全的证书
做法1：在网站响应头里面加入强制性声明
```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```
上面这段头信息有两个作用：
* 接下来一年（31536000秒）中，浏览器只要向test.com与其子域名发送HTTP请求时，必须采用HTTPS来发起连接
* 接下来一年中，如果test.com服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站

措施2：确保浏览器只在使用HTTPS时，才发送Cookie  
做法2：在网站响应头 Set-Cookie 字段加上 Secure 标志即可
```
Set-Cookie: LSID=DQAAAK...Eaem_vYg; Secure
```
